import logging
from decimal import Decimal
from typing import Dict, List, Optional

from hummingbot.core.data_type.common import OrderType, PriceType, TradeType
from hummingbot.core.data_type.order_candidate import OrderCandidate
from hummingbot.core.event.events import OrderFilledEvent
from hummingbot.strategy.script_strategy_base import ScriptStrategyBase
from hummingbot.data_feed.candles_feed.candles_factory import CandlesFactory, CandlesConfig
from hummingbot.connector.connector_base import ConnectorBase

class PMMVolTrendInventory(ScriptStrategyBase):
    trading_pair = "ETH-USDT"
    exchange = "binance_paper_trade"
    base, quote = trading_pair.split("-")

    bid_spread_scalar = 80
    ask_spread_scalar = 80
    max_shift_bps = 30
    order_refresh_time = 30
    order_amount = 0.01
    price_source = PriceType.MidPrice

    target_inventory_ratio = 0.5
    inventory_scalar = 0.5
    skew_cap = 0.01

    sma_fast_period = 10
    sma_slow_period = 30
    rsi_period = 14
    candle_interval = "1m"
    max_records = 1000

    auto_close_enabled = True
    min_profit_threshold = Decimal("0.5")

    create_timestamp = 0
    candles = CandlesFactory.get_candle(CandlesConfig(
        connector="binance", trading_pair=trading_pair, interval=candle_interval, max_records=max_records
    ))
    markets = {exchange: {trading_pair}}

    def __init__(self, connectors: Dict[str, ConnectorBase]):
        super().__init__(connectors)
        self.candles.start()
        self.realized_pnl = Decimal("0")
        self.starting_value = None
        self.position_ledger = []  # [(side, amount, price)] FIFO ledger

    def on_stop(self):
        self.candles.stop()

    def on_tick(self):
        if self.create_timestamp <= self.current_timestamp and self.ready_to_trade:
            self.track_portfolio_value()
            self.auto_close_profitable_positions()
            self.cancel_all_orders()
            self.update_signals()
            proposal = self.create_proposal()
            proposal_adjusted = self.adjust_proposal_to_budget(proposal)
            self.place_orders(proposal_adjusted)
            self.create_timestamp = self.current_timestamp + self.order_refresh_time

    def update_signals(self):
        self.candles_df = df = self.candles.candles_df.copy()
        df.ta.rsi(length=self.rsi_period, append=True)
        df.ta.natr(length=self.sma_slow_period, append=True)
        df.ta.sma(length=self.sma_fast_period, append=True)
        df.ta.sma(length=self.sma_slow_period, append=True)

    def get_volatility_spreads(self):
        natr = self.candles_df[f"NATR_{self.sma_slow_period}"].iloc[-1]
        raw_bid_spread = natr * self.bid_spread_scalar
        raw_ask_spread = natr * self.ask_spread_scalar

        min_spread = 0.002
        max_spread = 0.005
        bid_spread = max(min_spread, min(raw_bid_spread, max_spread))
        ask_spread = max(min_spread, min(raw_ask_spread, max_spread))

        return bid_spread, ask_spread

    def get_trend_bias(self):
        rsi = self.candles_df[f"RSI_{self.rsi_period}"].iloc[-1]
        sma_fast = self.candles_df[f"SMA_{self.sma_fast_period}"].iloc[-1]
        sma_slow = self.candles_df[f"SMA_{self.sma_slow_period}"].iloc[-1]

        bias = (50 - rsi) / 50  # reverse RSI: favors down when overbought
        if sma_fast < sma_slow:
            bias += 0.25  # reverse: bias up in downtrend
        elif sma_fast > sma_slow:
            bias -= 0.25  # reverse: bias down in uptrend

        return max(-1, min(1, bias)) * self.max_shift_bps / 10000

    def get_inventory_bias(self):
        base_bal = self.connectors[self.exchange].get_balance(self.base)
        quote_bal = self.connectors[self.exchange].get_balance(self.quote)
        price = self.connectors[self.exchange].get_price_by_type(self.trading_pair, self.price_source)
        base_value = base_bal * price
        total_value = base_value + quote_bal

        if total_value == 0:
            return 0

        current_ratio = float(base_value / total_value)
        deviation = (current_ratio - self.target_inventory_ratio) / self.target_inventory_ratio
        # ^ reversed: buys more when already overweight
        bias = max(-1, min(1, deviation)) * self.max_shift_bps / 10000 * self.inventory_scalar
        return max(-self.skew_cap, min(self.skew_cap, bias))


    def create_proposal(self) -> List[OrderCandidate]:
        ref_price = self.connectors[self.exchange].get_price_by_type(self.trading_pair, self.price_source)
        vol_bid_spread, vol_ask_spread = self.get_volatility_spreads()
        trend_shift = self.get_trend_bias()
        inventory_shift = self.get_inventory_bias()

        adjusted_mid = ref_price * Decimal(1 + trend_shift + inventory_shift)
        buy_price = adjusted_mid * Decimal(1 - vol_bid_spread)
        sell_price = adjusted_mid * Decimal(1 + vol_ask_spread)

        min_price = Decimal("0.01")
        if buy_price < min_price or sell_price < min_price:
            self.log_with_clock(logging.WARNING, f"Prices too low! Buy: {buy_price}, Sell: {sell_price}, forcing to 0.01")
            buy_price = max(buy_price, min_price)
            sell_price = max(sell_price, min_price)

        buy = OrderCandidate(self.trading_pair, True, OrderType.LIMIT, TradeType.BUY,
                             Decimal(self.order_amount), buy_price)
        sell = OrderCandidate(self.trading_pair, True, OrderType.LIMIT, TradeType.SELL,
                              Decimal(self.order_amount), sell_price)

        return [buy, sell]

    def adjust_proposal_to_budget(self, proposal: List[OrderCandidate]) -> List[OrderCandidate]:
        return self.connectors[self.exchange].budget_checker.adjust_candidates(proposal, all_or_none=True)

    def place_orders(self, proposal: List[OrderCandidate]):
        for order in proposal:
            self.place_order(self.exchange, order)

    def place_order(self, connector_name: str, order: OrderCandidate):
        if order.order_side == TradeType.BUY:
            self.buy(connector_name, order.trading_pair, order.amount, order.order_type, order.price)
        else:
            self.sell(connector_name, order.trading_pair, order.amount, order.order_type, order.price)

    def cancel_all_orders(self):
        for order in self.get_active_orders(self.exchange):
            self.cancel(self.exchange, order.trading_pair, order.client_order_id)

    def did_fill_order(self, event: OrderFilledEvent):
        msg = f"{event.trade_type.name} {round(event.amount, 4)} {event.trading_pair} at {round(event.price, 2)}"
        self.log_with_clock(logging.INFO, msg)
        self.notify_hb_app_with_timestamp(msg)

        # Improved PnL accounting using FIFO ledger
        if event.trade_type == TradeType.BUY:
            self.position_ledger.append((TradeType.BUY, event.amount, Decimal(event.price)))
        elif event.trade_type == TradeType.SELL:
            remaining = event.amount
            while remaining > 0 and self.position_ledger:
                side, qty, price = self.position_ledger[0]
                if side != TradeType.BUY:
                    self.position_ledger.pop(0)
                    continue
                trade_qty = min(qty, remaining)
                pnl = trade_qty * (Decimal(event.price) - price)
                self.realized_pnl += pnl
                remaining -= trade_qty
                if qty > trade_qty:
                    self.position_ledger[0] = (side, qty - trade_qty, price)
                else:
                    self.position_ledger.pop(0)


    def auto_close_profitable_positions(self):
        if not self.auto_close_enabled or not self.position_ledger:
            return

        price = self.connectors[self.exchange].get_price_by_type(self.trading_pair, self.price_source)
        sellable = Decimal("0")

        for side, qty, entry_price in self.position_ledger:
            if side != TradeType.BUY:
                continue
            unrealized_pnl = (price - entry_price) * qty
            if unrealized_pnl >= self.min_profit_threshold:
                sellable += qty
            else:
                break  # FIFO: stop at first unqualified position

        if sellable > 0:
            self.cancel_all_orders()
            self.log_with_clock(logging.INFO, f"Auto-closing {sellable} {self.base} at {price} to realize profit.")
            self.sell(self.exchange, self.trading_pair, sellable, OrderType.MARKET)



    def track_portfolio_value(self):
        base_bal = self.connectors[self.exchange].get_balance(self.base)
        quote_bal = self.connectors[self.exchange].get_balance(self.quote)
        price = self.connectors[self.exchange].get_price_by_type(self.trading_pair, self.price_source)
        base_value = base_bal * price
        total_value = base_value + quote_bal

        if self.starting_value is None:
            self.starting_value = total_value

        net_pnl = total_value - self.starting_value

        self.log_with_clock(logging.INFO, f"Net PnL: {net_pnl:.2f}, Total Value: {total_value:.2f}")

    def format_status(self) -> str:
        lines = ["", f"Market Making Status: {self.trading_pair} on {self.exchange}"]
        try:
            df = self.active_orders_df()
            lines.extend(["", "  Active Orders:"] + ["    " + line for line in df.to_string(index=False).split("\n")])
        except ValueError:
            lines.append("  No active orders.")

        try:
            lines.append("\n  Indicators:")
            last = self.candles_df.iloc[-1]
            lines.append(f"    RSI: {last[f'RSI_{self.rsi_period}']:.2f}")
            lines.append(f"    SMA Fast: {last[f'SMA_{self.sma_fast_period}']:.2f}")
            lines.append(f"    SMA Slow: {last[f'SMA_{self.sma_slow_period}']:.2f}")
            lines.append(f"    NATR: {last[f'NATR_{self.sma_slow_period}']:.5f}")
        except Exception:
            lines.append("  Candles data not ready.")

        try:
            base_bal = self.connectors[self.exchange].get_balance(self.base)
            quote_bal = self.connectors[self.exchange].get_balance(self.quote)
            price = self.connectors[self.exchange].get_price_by_type(self.trading_pair, self.price_source)
            total_value = base_bal * price + quote_bal
            net_pnl = total_value - self.starting_value if self.starting_value else Decimal("0")
            #lines.append(f"\n  Realized PnL: {self.realized_pnl:.2f}")
            lines.append(f"  Net PnL: {net_pnl:.2f}")
            lines.append(f"  Total Value: {total_value:.2f}")
        except Exception as e:
            lines.append(f"\n  PnL info unavailable: {e}")

        return "\n".join(lines)
